// ActiveHosts calls Manager.ActiveHosts.
func (s *Satellite) ActiveHosts() ([]smodules.HostDBEntry, error) { return s.m.ActiveHosts() }

// AllHosts calls Manager.AllHosts.
func (s *Satellite) AllHosts() ([]smodules.HostDBEntry, error) { return s.m.AllHosts() }

// Filter calls Manager.Filter.
func (s *Satellite) Filter() (smodules.FilterMode, map[string]types.SiaPublicKey, []string, error) { return s.m.Filter() }

// SetFilterMode calls Manager.SetFilterMode.
func (s *Satellite) SetFilterMode(lm smodules.FilterMode, hosts []types.SiaPublicKey, netAddresses []string) error { return s.m.SetFilterMode(lm, hosts, netAddresses) }

// Host calls Manager.Host.
func (s *Satellite) Host(spk types.SiaPublicKey) (smodules.HostDBEntry, bool, error) { return s.m.Host(spk) }

// InitialScanComplete calls Manager.InitialScanComplete.
func (s *Satellite) InitialScanComplete() (bool, types.BlockHeight, error) { return s.m.InitialScanComplete() }

// ScoreBreakdown calls Manager.ScoreBreakdown.
func (s *Satellite) ScoreBreakdown(e smodules.HostDBEntry) (smodules.HostScoreBreakdown, error) { return s.m.ScoreBreakdown(e) }

// EstimateHostScore calls Manager.EstimateHostScore.
func (s *Satellite) EstimateHostScore(e smodules.HostDBEntry, a modules.Allowance) (smodules.HostScoreBreakdown, error) { return s.m.EstimateHostScore(e, a) }

// UserExists returns true if the renter's public key is found in the
// database. An error is returned as well.
func (s *Satellite) UserExists(rpk types.SiaPublicKey) (exists bool, err error) {
	var count int
	err = s.db.QueryRow("SELECT COUNT(*) FROM renters WHERE public_key = ?", rpk.String()).Scan(&count)
	if err != nil {
		s.log.Println("ERROR: could not query database", err)
	}
	exists = count > 0
	return
}

// GetRenter calls Manager.GetRenter.
func (s *Satellite) GetRenter(pk types.SiaPublicKey) (modules.Renter, error) {
	return s.m.GetRenter(pk)
}

// Renters calls Manager.Renters.
func (s *Satellite) Renters() []modules.Renter {
	return s.m.Renters()
}

// SetAllowance calls Manager.SetAllowance.
func (s *Satellite) SetAllowance(rpk types.SiaPublicKey, a modules.Allowance) error {
	return s.m.SetAllowance(rpk, a)
}

// FormContracts forms the specified number of contracts with the hosts
// and returns them.
func (s *Satellite) FormContracts(rpk types.SiaPublicKey, rsk crypto.SecretKey, a modules.Allowance) ([]modules.RenterContract, error) {
	// Get the estimated costs and update the allowance with them.
	estimation, a, err := s.m.PriceEstimation(a)
	if err != nil {
		return nil, err
	}

	// Check if the user balance is sufficient to cover the costs.
	renter, err := s.GetRenter(rpk)
	if err != nil {
		return nil, err
	}
	ub, err := s.GetBalance(renter.Email)
	if err != nil {
		return nil, err
	}
	if ub.Balance < estimation {
		return nil, errors.New("insufficient account balance")
	}

	// Set the allowance.
	err = s.m.SetAllowance(rpk, a)
	if err != nil {
		return nil, err
	}

	// Form the contracts.
	contractSet, err := s.m.FormContracts(rpk, rsk)

	return contractSet, err
}

// Contracts calls Manager.Contracts.
func (s *Satellite) Contracts() []modules.RenterContract {
	return s.m.Contracts()
}

// ContractsByRenter calls Manager.ContractsByRenter.
func (s *Satellite) ContractsByRenter(rpk types.SiaPublicKey) []modules.RenterContract {
	return s.m.ContractsByRenter(rpk)
}

// RefreshedContract calls Manager.RefreshedContract.
func (s *Satellite) RefreshedContract(fcid types.FileContractID) bool {
	return s.m.RefreshedContract(fcid)
}

// OldContracts calls Manager.OldContracts.
func (s *Satellite) OldContracts() []modules.RenterContract {
	return s.m.OldContracts()
}

// OldsContractsByRenter calls Manager.OldContractsByRenter.
func (s *Satellite) OldContractsByRenter(rpk types.SiaPublicKey) []modules.RenterContract {
	return s.m.OldContractsByRenter(rpk)
}

// RenewContracts tries to renew the given set of contracts and returns them.
// If the contracts are not up to being renewed yet, existing contracts are
// returned.
func (s *Satellite) RenewContracts(rpk types.SiaPublicKey, rsk crypto.SecretKey, a modules.Allowance, contracts []types.FileContractID) ([]modules.RenterContract, error) {
	// Get the estimated costs and update the allowance with them.
	estimation, a, err := s.m.PriceEstimation(a)
	if err != nil {
		return nil, err
	}

	// Check if the user balance is sufficient to cover the costs.
	renter, err := s.GetRenter(rpk)
	if err != nil {
		return nil, err
	}
	ub, err := s.GetBalance(renter.Email)
	if err != nil {
		return nil, err
	}
	if ub.Balance < estimation {
		return nil, errors.New("insufficient account balance")
	}

	// Set the allowance.
	err = s.m.SetAllowance(rpk, a)
	if err != nil {
		return nil, err
	}

	// Renew the contracts.
	contractSet, err := s.m.RenewContracts(rpk, rsk, contracts)

	return contractSet, err
}

// UpdateContract updates the contract with the new revision.
func (s *Satellite) UpdateContract(rev types.FileContractRevision, sigs []types.TransactionSignature, uploads, downloads, fundAccount types.Currency) error {
	return s.m.UpdateContract(rev, sigs, uploads, downloads, fundAccount)
}

// WalletSeed returns the primary wallet seed.
func (s *Satellite) WalletSeed() (seed smodules.Seed, err error) {
	seed, _, err = s.wallet.PrimarySeed()
	return
}

// RenewedFrom returns the ID of the contract the given contract was renewed
// from, if any.
func (s *Satellite) RenewedFrom(fcid types.FileContractID) types.FileContractID {
	return s.m.RenewedFrom(fcid)
}

// DeleteRenter deletes the renter data from the memory.
func (s *Satellite) DeleteRenter(email string) {
	s.m.DeleteRenter(email)
}

// FormContract creates a contract with a single host using the new
// Renter-Satellite protocol.
func (s *Satellite) FormContract(ss *modules.RPCSession, pk types.SiaPublicKey, rpk types.SiaPublicKey, hpk types.SiaPublicKey, endHeight types.BlockHeight, storage uint64, upload uint64, download uint64, minShards uint64, totalShards uint64) (modules.RenterContract, error) {
	// Get the estimated costs.
	funding, estimation, err := s.m.ContractPriceEstimation(hpk, endHeight, storage, upload, download, minShards, totalShards)
	if err != nil {
		return modules.RenterContract{}, err
	}

	// Check if the user balance is sufficient to cover the costs.
	renter, err := s.GetRenter(pk)
	if err != nil {
		return modules.RenterContract{}, err
	}
	ub, err := s.GetBalance(renter.Email)
	if err != nil {
		return modules.RenterContract{}, err
	}
	if ub.Balance < estimation {
		return modules.RenterContract{}, errors.New("insufficient account balance")
	}

	// Form the contract.
	contract, err := s.m.FormContract(ss, pk, rpk, hpk, endHeight, funding)

	return contract, err
}

// RenewContract renews a contract using the new Renter-Satellite protocol.
func (s *Satellite) RenewContract(ss *modules.RPCSession, pk types.SiaPublicKey, fcid types.FileContractID, endHeight types.BlockHeight, storage uint64, upload uint64, download uint64, minShards uint64, totalShards uint64) (modules.RenterContract, error) {
	// Get the contract to renew.
	contract, exists := s.Contract(fcid)
	if !exists {
		return modules.RenterContract{}, errors.New("contract not found")
	}

	// Get the estimated costs.
	funding, estimation, err := s.m.ContractPriceEstimation(contract.HostPublicKey, endHeight, storage, upload, download, minShards, totalShards)
	if err != nil {
		return modules.RenterContract{}, err
	}

	// Check if the user balance is sufficient to cover the costs.
	renter, err := s.GetRenter(pk)
	if err != nil {
		return modules.RenterContract{}, err
	}
	ub, err := s.GetBalance(renter.Email)
	if err != nil {
		return modules.RenterContract{}, err
	}
	if ub.Balance < estimation {
		return modules.RenterContract{}, errors.New("insufficient account balance")
	}

	// Renew the contract.
	newContract, err := s.m.RenewContract(ss, pk, contract, endHeight, funding)

	return newContract, err
}

// Contract calls Manager.Contract.
func (s *Satellite) Contract(fcid types.FileContractID) (modules.RenterContract, bool) {
	return s.m.Contract(fcid)
}

// UpdateRenterSettings calls Manager.UpdateRenterSettings.
func (s *Satellite) UpdateRenterSettings(rpk types.SiaPublicKey, settings modules.RenterSettings, sk crypto.SecretKey) error {
	return s.m.UpdateRenterSettings(rpk, settings, sk)
}
