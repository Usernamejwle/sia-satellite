package proto

import (
	"context"
	"errors"
	"fmt"
	"math"
	"net"

	"github.com/mike76-dev/sia-satellite/modules"

	rhpv2 "go.sia.tech/core/rhp/v2"
	rhpv3 "go.sia.tech/core/rhp/v3"
	"go.sia.tech/core/types"
	smodules "go.sia.tech/siad/modules"
	siad "go.sia.tech/siad/types"
)

// RenewContract negotiates a new contract for data already stored with
// a host, and submits the new contract transaction to tpool. The new
// contract is added to the ContractSet and its metadata is returned.
// The new Renter-Satellite protocol is used.
func (cs *ContractSet) RenewContract(s *modules.RPCSession, oldFC *FileContract, pk, renterKey types.SiaPublicKey, host smodules.HostDBEntry, startHeight, endHeight types.BlockHeight, funding types.Currency, refundAddress types.UnlockHash, txnBuilder transactionBuilder, tpool transactionPool, hdb hostDB, cancel <-chan struct{}) (rc modules.RenterContract, formationTxnSet []types.Transaction, err error) {
	// For convenience.
	oldContract := oldFC.header

	// Create a context and set up its cancelling.
	ctx, cancelFunc := context.WithTimeout(context.Background(), contractHostRenewTimeout)
	go func() {
		select {
		case <-cancel:
			cancelFunc()
		case <-ctx.Done():
		}
	}()

	// Initiate protocol.
	hostName, _, err := net.SplitHostPort(string(host.NetAddress))
	if err != nil {
		return modules.RenterContract{}, nil, fmt.Errorf("failed to get host name: %s", err)
	}
	siamuxAddr := net.JoinHostPort(hostName, host.SiaMuxPort)

	// Increase Successful/Failed interactions accordingly.
	defer func() {
		if err != nil {
			hdb.IncrementFailedInteractions(host.PublicKey)
			err = fmt.Errorf("%s: %s", smodules.ErrHostFault, err)
		} else if err == nil {
			hdb.IncrementSuccessfulInteractions(host.PublicKey)
		}
	}()

	var noOpRevTxn, finalRevTxn types.Transaction
	var txnFee, basePrice, baseCollateral, renewCost types.Currency
	var fc types.FileContract
	err = WithTransportV3(ctx, siamuxAddr, host.PublicKey, func(t *rhpv3.Transport) (err error) {
		// Fetch the latest revision.
		rev, err := RPCLatestRevision(t, core.FileContractID(oldContract.ID()))
		if err != nil {
			return fmt.Errorf("unable to get latest revision: %s", err)
		}
		oldRev := convertRevision(rev)

		// Fetch the price table.
		rhp3pt, err := RPCPriceTable(t, func(pt rhpv3.HostPriceTable) (rhpv3.PaymentMethod, error) { return nil, nil })
		if err != nil {
			return fmt.Errorf("unable to get price table: %s", err)
		}
		pt := modules.ConvertPriceTable(rhp3pt)

		// RHP3 contains both the contract and final revision. So we double the
		// estimation.
		txnFee = pt.TxnFeeMaxRecommended.Mul64(2 * smodules.EstimatedFileContractTransactionSetSize)

		// Calculate the base cost. This includes the RPC cost.
		basePrice, baseCollateral = smodules.RenewBaseCosts(oldRev, &pt, endHeight)

		// Create the final revision of the old contract.
		renewCost = types.ZeroCurrency
		finalRev, err := oldRev.PaymentRevision(renewCost)
		if err != nil {
			return fmt.Errorf("unable to create final revision: %s", err)
		}

		// Clear the revision.
		finalRev.NewFileSize = 0
		finalRev.NewFileMerkleRoot = crypto.Hash{}
		finalRev.NewRevisionNumber = math.MaxUint64

		// The valid proof outputs become the missed ones since the host won't need
		// to provide a storage proof.
		finalRev.NewMissedProofOutputs = finalRev.NewValidProofOutputs

		// Calculate the payouts for the renter, host, and whole contract.
		period := endHeight - startHeight
		expectedStorage := fundsToExpectedStorage(funding, period, host)
		renterPayout, hostPayout, hostCollateral, err := smodules.RenterPayoutsPreTax(host, funding, txnFee, basePrice, baseCollateral, period, expectedStorage)
		if err != nil {
			return fmt.Errorf("unable to calculate payouts: %s", err)
		}
		totalPayout := renterPayout.Add(hostPayout)

		// Check for negative currency.
		if hostCollateral.Cmp(baseCollateral) < 0 {
			baseCollateral = hostCollateral
		}
		if types.PostTax(startHeight, totalPayout).Cmp(hostPayout) < 0 {
			return errors.New("insufficient funds to pay both siafund fee and also host payout")
		}

		// Create unlock conditions.
		uc := types.UnlockConditions{
			PublicKeys: []types.SiaPublicKey{
				renterKey,
				host.PublicKey,
			},
			SignaturesRequired: 2,
		}

		// Create file contract.
		renterPostTaxPayout := types.PostTax(startHeight, totalPayout).Sub(hostPayout)
		fc := types.FileContract{
			FileSize:       oldRev.NewFileSize,
			FileMerkleRoot: oldRev.NewFileMerkleRoot,
			WindowStart:    endHeight,
			WindowEnd:      endHeight + host.WindowSize,
			Payout:         totalPayout,
			UnlockHash:     uc.UnlockHash(),
			RevisionNumber: 0,
			ValidProofOutputs: []types.SiacoinOutput{
				// Renter.
				{Value: renterPostTaxPayout, UnlockHash: refundAddress},
				// Host.
				{Value: hostPayout, UnlockHash: host.UnlockHash},
			},
			MissedProofOutputs: []types.SiacoinOutput{
				// Renter.
				{Value: renterPostTaxPayout, UnlockHash: refundAddress},
				// Host gets its unused collateral back, plus the contract price.
				{Value: hostCollateral.Sub(baseCollateral).Add(host.ContractPrice), UnlockHash: host.UnlockHash},
				// Void gets the spent storage fees, plus the collateral being risked.
				{Value: basePrice.Add(baseCollateral), UnlockHash: types.UnlockHash{}},
			},
		}

		// Add both the new final revision and the new contract to the same
		// transaction.
		txnBuilder.AddFileContractRevision(finalRev)
		txnBuilder.AddFileContract(fc)

		// Add the fee to the transaction.
		txnBuilder.AddMinerFee(txnFee)

		// Create transaction set.
		txnSet, err := prepareTransactionSet(txnBuilder)
		if err != nil {
			return fmt.Errorf("failed to prepare txnSet with finalRev and new contract: %s", err)
		}

		// Prepare the final revision.
		finalRevRenterSig := types.TransactionSignature{
			ParentID:       crypto.Hash(finalRev.ParentID),
			PublicKeyIndex: 0,
			CoveredFields: types.CoveredFields{
				FileContracts:         []uint64{0},
				FileContractRevisions: []uint64{0},
			},
		}
		finalRevTxn, _ = txnBuilder.View()
		finalRevTxn.TransactionSignatures = append(finalRevTxn.TransactionSignatures, finalRevRenterSig)

		// Calculate the txn hash and send it to the renter.
		sr := &signRequest{
			RevisionHash: finalRevTxn.SigHash(0, startHeight),
		}
		if err := s.WriteResponse(sr); err != nil {
			return fmt.Errorf("couldn't send txn hash to the renter: %s", err)
		}

		// Read the renter signature and add it to the txn.
		var srr signResponse
		if err := s.ReadResponse(&srr, 65536); err != nil {
			return fmt.Errorf("couldn't read renter signature: %s", err)
		}
		finalRevTxn.TransactionSignatures[0].Signature = srr.Signature[:]

		noOpRevTxn, err = RPCRenewOldContract(s, t, txnBuilder, txnSet, renterKey, host.PublicKey, finalRevTxn, startHeight)
		return err
	})
	if err != nil {
		return modules.RenterContract{}, nil, fmt.Errorf("failed to renew contract: %s", err)
	}

	// Construct the final transaction.
	txnSet, err := prepareTransactionSet(txnBuilder)
	if err != nil {
		return modules.RenterContract{}, nil, fmt.Errorf("failed to prepare txnSet with finalRev and new contract: %s", err)
	}

	// Submit to blockchain.
	err = tpool.AcceptTransactionSet(txnSet)
	if err == smodules.ErrDuplicateTransactionSet {
		// As long as it made it into the transaction pool, we're good.
		err = nil
	}
	if err != nil {
		return modules.RenterContract{}, nil, fmt.Errorf("failed to submit txnSet for renewal to blockchain: %s", err)
	}

	// Construct contract header.
	header := contractHeader{
		Transaction:     noOpRevTxn,
		StartHeight:     startHeight,
		TotalCost:       funding,
		ContractFee:     host.ContractPrice,
		TxnFee:          txnFee,
		SiafundFee:      types.Tax(startHeight, fc.Payout),
		StorageSpending: basePrice,
		Utility: smodules.ContractUtility{
			GoodForUpload: true,
			GoodForRenew:  true,
		},
	}

	// Add contract to the set.
	meta, err := cs.managedInsertContract(header, pk)
	if err != nil {
		return modules.RenterContract{}, nil, err
	}

	// Commit changes to old contract.
	if err := oldFC.managedCommitClearContract(finalRevTxn, renewCost); err != nil {
		return modules.RenterContract{}, nil, err
	}
	return meta, txnSet, nil
}
