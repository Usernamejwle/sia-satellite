package wallet

import (
	"fmt"

	"github.com/mike76-dev/sia-satellite/modules"
	"go.sia.tech/core/types"
	"go.sia.tech/coreutils/chain"
)

const scanMultiplier = 4 // how many more keys to generate after each scan iteration

var errMaxKeys = fmt.Errorf("refused to generate more than %v keys from seed", maxScanKeys)

// maxScanKeys is the number of maximum number of keys the seedScanner will
// generate before giving up.
const maxScanKeys = uint64(100e6)

// numInitialKeys is the number of keys generated by the seedScanner before
// scanning the blockchain for the first time.
const numInitialKeys = uint64(1e6)

// A scannedOutput is an output found in the blockchain that was generated
// from a given seed.
type scannedOutput struct {
	id        types.Hash256
	value     types.Currency
	seedIndex uint64
}

// A seedScanner scans the blockchain for addresses that belong to a given
// seed.
type seedScanner struct {
	dustThreshold    types.Currency           // minimum value of outputs to be included
	keys             map[types.Address]uint64 // map address to seed index
	largestIndexSeen uint64                   // largest index that has appeared in the blockchain
	scannedHeight    uint64
	seed             modules.Seed
	siacoinOutputs   map[types.SiacoinOutputID]scannedOutput
	siafundOutputs   map[types.SiafundOutputID]scannedOutput
}

func (s *seedScanner) numKeys() uint64 {
	return uint64(len(s.keys))
}

// generateKeys generates n additional keys from the seedScanner's seed.
func (s *seedScanner) generateKeys(n uint64) {
	initialProgress := s.numKeys()
	for i, key := range generateKeys(s.seed, initialProgress, n) {
		s.keys[types.StandardUnlockHash(key.PublicKey())] = initialProgress + uint64(i)
	}
}

// ProcessChainApplyUpdate implements chain.Subscriber
func (s *seedScanner) ProcessChainApplyUpdate(cau *chain.ApplyUpdate, _ bool) error {
	cau.ForEachSiacoinElement(func(sce types.SiacoinElement, spent bool) {
		index, exists := s.keys[sce.SiacoinOutput.Address]
		if exists {
			if spent {
				delete(s.siacoinOutputs, types.SiacoinOutputID(sce.ID))
			} else if sce.SiacoinOutput.Value.Cmp(s.dustThreshold) > 0 {
				s.siacoinOutputs[types.SiacoinOutputID(sce.ID)] = scannedOutput{
					id:        sce.ID,
					value:     sce.SiacoinOutput.Value,
					seedIndex: index,
				}
			}
			if index > s.largestIndexSeen {
				s.largestIndexSeen = index
			}
		}
	})

	cau.ForEachSiafundElement(func(sfe types.SiafundElement, spent bool) {
		index, exists := s.keys[sfe.SiafundOutput.Address]
		if exists {
			if spent {
				delete(s.siafundOutputs, types.SiafundOutputID(sfe.ID))
			} else {
				s.siafundOutputs[types.SiafundOutputID(sfe.ID)] = scannedOutput{
					id:        sfe.ID,
					value:     types.NewCurrency(sfe.SiafundOutput.Value, 0),
					seedIndex: index,
				}
			}
			if index > s.largestIndexSeen {
				s.largestIndexSeen = index
			}
		}
	})

	s.scannedHeight = cau.State.Index.Height
	fmt.Printf("\rWallet: scanned to height %d...", s.scannedHeight)

	return nil
}

// ProcessChainRevertUpdate implements chain.Subscriber
func (s *seedScanner) ProcessChainRevertUpdate(cru *chain.RevertUpdate) error {
	cru.ForEachSiacoinElement(func(sce types.SiacoinElement, spent bool) {
		index, exists := s.keys[sce.SiacoinOutput.Address]
		if exists {
			if !spent {
				delete(s.siacoinOutputs, types.SiacoinOutputID(sce.ID))
			} else if sce.SiacoinOutput.Value.Cmp(s.dustThreshold) > 0 {
				s.siacoinOutputs[types.SiacoinOutputID(sce.ID)] = scannedOutput{
					id:        sce.ID,
					value:     sce.SiacoinOutput.Value,
					seedIndex: index,
				}
			}
			if index > s.largestIndexSeen {
				s.largestIndexSeen = index
			}
		}
	})

	cru.ForEachSiafundElement(func(sfe types.SiafundElement, spent bool) {
		index, exists := s.keys[sfe.SiafundOutput.Address]
		if exists {
			if !spent {
				delete(s.siafundOutputs, types.SiafundOutputID(sfe.ID))
			} else {
				s.siafundOutputs[types.SiafundOutputID(sfe.ID)] = scannedOutput{
					id:        sfe.ID,
					value:     types.NewCurrency(sfe.SiafundOutput.Value, 0),
					seedIndex: index,
				}
			}
			if index > s.largestIndexSeen {
				s.largestIndexSeen = index
			}
		}
	})

	s.scannedHeight = cru.State.Index.Height
	return nil
}

// scan subscribes s to cm and scans the blockchain for addresses that belong
// to s's seed. If scan returns errMaxKeys, additional keys may need to be
// generated to find all the addresses.
func (s *seedScanner) scan(cm *chain.Manager) error {
	// Generate a bunch of keys and scan the blockchain looking for them. If
	// none of the 'upper' half of the generated keys are found, we are done;
	// otherwise, generate more keys and try again (bounded by a sane
	// default).
	//
	// NOTE: since scanning is very slow, we aim to only scan once, which
	// means generating many keys.
	numKeys := numInitialKeys
	for s.numKeys() < maxScanKeys {
		s.generateKeys(numKeys)

		// Reset scan height between scans.
		s.scannedHeight = 0
		if err := cm.AddSubscriber(s, types.ChainIndex{}); err != nil {
			return err
		}
		cm.RemoveSubscriber(s)
		if s.largestIndexSeen < s.numKeys()/2 {
			return nil
		}

		// Increase number of keys generated each iteration, capping so that
		// we do not exceed maxScanKeys.
		numKeys *= scanMultiplier
		if numKeys > maxScanKeys-s.numKeys() {
			numKeys = maxScanKeys - s.numKeys()
		}
	}
	return errMaxKeys
}

// newSeedScanner returns a new seedScanner.
func newSeedScanner(seed modules.Seed, dustThreshold types.Currency) *seedScanner {
	return &seedScanner{
		seed:           seed,
		dustThreshold:  dustThreshold,
		keys:           make(map[types.Address]uint64, numInitialKeys),
		siacoinOutputs: make(map[types.SiacoinOutputID]scannedOutput),
		siafundOutputs: make(map[types.SiafundOutputID]scannedOutput),
	}
}
