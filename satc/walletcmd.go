package main

import (
	"fmt"

	"github.com/spf13/cobra"
)

var (
	walletAddressCmd = &cobra.Command{
		Use:   "address",
		Short: "Get a new wallet address",
		Long:  "Generate a new wallet address from the wallet's seed.",
		Run:   wrap(walletaddresscmd),
	}

	walletAddressesCmd = &cobra.Command{
		Use:   "addresses",
		Short: "List all addresses",
		Long:  "List all addresses that have been generated by the wallet.",
		Run:   wrap(walletaddressescmd),
	}

	walletBalanceCmd = &cobra.Command{
		Use:   "balance",
		Short: "View wallet balance",
		Long:  "View wallet balance, including confirmed and unconfirmed balance.",
		Run:   wrap(walletbalancecmd),
	}

	walletCmd = &cobra.Command{
		Use:   "wallet",
		Short: "Perform wallet actions",
		Long: `Generate a new address, send coins to another wallet, or view info about the wallet.
Units:
The smallest unit of Siacoins is the Hasting. One Siacoin is 10^24 Hastings. Other supported units are:
  pS (pico,  10^-12 SC)
  nS (nano,  10^-9 SC)
  uS (micro, 10^-6 SC)
  mS (milli, 10^-3 SC)
  SC
  KS (kilo, 10^3 SC)
  MS (mega, 10^6 SC)
  GS (giga, 10^9 SC)
  TS (tera, 10^12 SC)`,
		Run: wrap(walletbalancecmd),
	}

	/*walletSendCmd = &cobra.Command{
			Use:   "send",
			Short: "Send Siacoins to an address",
			Long:  "Send Siacoins to an address",
			// Run field is not set, as the send command itself is not a valid command.
			// A subcommand must be provided.
		}

		walletSendSiacoinsCmd = &cobra.Command{
			Use:   "siacoins [amount] [dest]",
			Short: "Send Siacoins to an address",
			Long: `Send Siacoins to an address. 'dest' must be a 76-byte hexadecimal address.
	'amount' can be specified in units, e.g. 1.23KS. Run 'wallet --help' for a list of units.
	If no unit is supplied, Hastings will be assumed.
	A dynamic transaction fee is applied depending on the size of the transaction and how busy the network is.`,
			Run: wrap(walletsendsiacoinscmd),
		}*/
)

// walletaddresscmd fetches a new address from the wallet that will be able to
// receive coins.
func walletaddresscmd() {
	addr, err := httpClient.WalletAddress()
	if err != nil {
		die("Could not generate new address:", err)
	}
	fmt.Printf("Created new address: %s\n", addr)
}

// walletaddressescmd fetches the list of addresses that the wallet knows.
func walletaddressescmd() {
	addrs, err := httpClient.WalletAddresses()
	if err != nil {
		die("Failed to fetch addresses:", err)
	}
	for _, addr := range addrs {
		fmt.Println(addr)
	}
}

// walletsendsiacoinscmd sends Siacoins to a destination address.
/*func walletsendsiacoinscmd(amount, dest string) {
	value, err := types.ParseCurrency(amount)
	if err != nil {
		die("Could not parse amount:", err)
	}
	var hash types.Address
	if err := hash.UnmarshalText([]byte(dest)); err != nil {
		die("Failed to parse destination address", err)
	}
	_, err = httpClient.WalletSiacoinsPost(value, hash, walletTxnFeeIncluded)
	if err != nil {
		die("Could not send Siacoins:", err)
	}
	fmt.Printf("Sent %s Hastings to %s\n", value.ExactString(), dest)
}*/

// walletbalancecmd retrieves and displays information about the wallet.
func walletbalancecmd() {
	status, err := httpClient.WalletBalance()
	if err != nil {
		die("Could not get wallet status:", err)
	}

	unconfirmedBalance := status.Siacoins.Add(status.IncomingSiacoins).Sub(status.OutgoingSiacoins)
	var delta string
	if unconfirmedBalance.Cmp(status.Siacoins) >= 0 {
		delta = "+" + unconfirmedBalance.Sub(status.Siacoins).String()
	} else {
		delta = "-" + status.Siacoins.Sub(unconfirmedBalance).String()
	}

	fmt.Printf(`Wallet status:
Height:               %v
Confirmed SC Balance: %v
Unconfirmed Delta:    %v
Exact:                %v H
SF Balance:           %v
Estimated Fee:        %v / KB
`, status.Height, status.Siacoins, delta,
		status.Siacoins.ExactString(), status.Siafunds,
		status.RecommendedFee.Mul64(1e3))
}
